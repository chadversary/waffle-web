<!DOCTYPE html>
<html>

  <head>
    <title>Waffle/Examples/gl_basic</title>

    <link href="../waffle.css" rel="stylesheet" type="text/css">

    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="Generator" content="Vim/7.3">
    <meta name="plugin-version" content="vim7.3_v10">
    <meta name="syntax" content="c">
  </head>

<body>

<h1><img src="../waffle.jpg" alt="Yummy waffles"/></h1>

<h2><a href="../index.html">Waffle</a>/<a href="index.html">Examples</a>/gl_basic</h2>

<pre class="code">

<span class="Comment">/// @file gl_basic.c</span>
<span class="Comment">/// @brief Do some basic GL rendering using Waffle.</span>
<span class="Comment">///</span>
<span class="Comment">/// This example does the following:</span>
<span class="Comment">///     1. Dynamically choose the platform and GL API according to command</span>
<span class="Comment">///        line arguments.</span>
<span class="Comment">///     2. Create a window and GL context.</span>
<span class="Comment">///     3. Fill the window with red, then green, then blue, sleeping between</span>
<span class="Comment">///        each buffer swap.</span>

<span class="PreProc">#define _POSIX_C_SOURCE </span><span class="Constant">199309L</span><span class="PreProc"> </span><span class="Comment">// glibc feature macro for nanosleep.</span>

<span class="PreProc">#include </span><span class="Constant">&lt;stdarg.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdbool.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;</span>

<span class="PreProc">#ifdef __APPLE__</span>
<span class="PreProc">#    include </span><span class="Constant">&lt;Cocoa/Cocoa.h&gt;</span>
<span class="PreProc">#endif</span>

<span class="PreProc">#include </span><span class="Constant">&quot;waffle.h&quot;</span>

<span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *usage_message =
    <span class="Constant">&quot;usage:</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;    gl_basic &lt;platform&gt; &lt;context_api&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;arguments:</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;    platform: One of android, cgl, glx, wayland, x11_egl.</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;    context_api: One of gl, gles1, gles2.</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;example:</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;    gl_basic glx gl</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;description:</span><span class="Special">\n</span><span class="Constant">&quot;</span>
    <span class="Constant">&quot;    Create a window. Fill it with red, green, then blue.</span><span class="Special">\n</span><span class="Constant">&quot;</span>;

<span class="Comment">/// @defgroup Error handlers</span>
<span class="Comment">/// @{</span>
<span class="Comment">///</span>
<span class="Comment">/// All error handlers exit.</span>
<span class="Comment">///</span>

<span class="Type">static</span> <span class="Type">void</span>
gl_basic_error(<span class="Type">const</span> <span class="Type">char</span> *fmt, ...)
{
    <span class="Type">va_list</span> ap;

    fflush(<span class="Constant">stdout</span>);

    va_start(ap, fmt);
    fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;gl_basic: error: &quot;</span>);
    vfprintf(<span class="Constant">stderr</span>, fmt, ap);
    fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    va_end(ap);

    exit(<span class="Constant">EXIT_FAILURE</span>);
}
<span class="Type">static</span> <span class="Type">void</span>
error_usage(<span class="Type">void</span>)
{
    fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;usage error</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, usage_message);
    exit(<span class="Constant">EXIT_FAILURE</span>);
}


<span class="Type">static</span> <span class="Type">void</span>
error_waffle(<span class="Type">void</span>)
{
    <span class="Type">const</span> <span class="Type">struct</span> waffle_error_info *info = waffle_error_get_info();
    <span class="Type">const</span> <span class="Type">char</span> *code = waffle_error_to_string(info-&gt;code);

    <span class="Statement">if</span> (info-&gt;message_length &gt; <span class="Constant">0</span>)
        gl_basic_error(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, code, info-&gt;message);
    <span class="Statement">else</span>
        gl_basic_error(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, code);
}

<span class="Type">static</span> <span class="Type">void</span>
error_get_gl_symbol(<span class="Type">const</span> <span class="Type">char</span> *name)
{
    gl_basic_error(<span class="Constant">&quot;failed to get function pointer for </span><span class="Special">%s</span><span class="Constant">&quot;</span>, name);
}

<span class="Comment">/// @}</span>
<span class="Comment">/// @defgroup GL decalrations</span>
<span class="Comment">/// @{</span>

<span class="Type">typedef</span> <span class="Type">float</span> GLclampf;
<span class="Type">typedef</span> <span class="Type">unsigned</span> <span class="Type">int</span> GLbitfield;
<span class="Type">typedef</span> <span class="Type">unsigned</span> <span class="Type">int</span> GLint;
<span class="Type">typedef</span> <span class="Type">int</span> GLsizei;
<span class="Type">typedef</span> <span class="Type">unsigned</span> <span class="Type">int</span> GLenum;
<span class="Type">typedef</span> <span class="Type">void</span> GLvoid;

<span class="Type">enum</span> {
    <span class="Comment">// Copied for &lt;GL/gl.h&gt;.</span>
    GL_UNSIGNED_BYTE =    <span class="Constant">0x00001401</span>,
    GL_RGBA =             <span class="Constant">0x00001908</span>,
    GL_COLOR_BUFFER_BIT = <span class="Constant">0x00004000</span>,
};

<span class="PreProc">#define WINDOW_WIDTH  </span><span class="Constant">320</span>
<span class="PreProc">#define WINDOW_HEIGHT </span><span class="Constant">240</span>

<span class="Type">static</span> <span class="Type">void</span> (*glClearColor)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
<span class="Type">static</span> <span class="Type">void</span> (*glClear)(GLbitfield mask);
<span class="Type">static</span> <span class="Type">void</span> (*glReadPixels)(GLint x, GLint y, GLsizei width, GLsizei height,
                            GLenum format, GLenum type, GLvoid* data);

<span class="Comment">/// @}</span>
<span class="Comment">/// @defgroup Parsing Options</span>
<span class="Comment">/// @{</span>

<span class="Type">struct</span> options {
    <span class="Comment">/// @brief One of `WAFFLE_PLATFORM_*`.</span>
    <span class="Type">int</span> platform;

    <span class="Comment">/// @brief One of `WAFFLE_CONTEXT_OPENGL_*`.</span>
    <span class="Type">int</span> context_api;

    <span class="Comment">/// @brief One of `WAFFLE_DL_*`.</span>
    <span class="Type">int</span> dl;

    <span class="Type">const</span> <span class="Type">char</span> *display_name;
};

<span class="Type">struct</span> enum_map {
    <span class="Type">int</span> i;
    <span class="Type">const</span> <span class="Type">char</span> *s;
};

<span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> enum_map platform_map[] = {
    {WAFFLE_PLATFORM_ANDROID,   <span class="Constant">&quot;android&quot;</span>       },
    {WAFFLE_PLATFORM_CGL,       <span class="Constant">&quot;cgl&quot;</span>,          },
    {WAFFLE_PLATFORM_GLX,       <span class="Constant">&quot;glx&quot;</span>           },
    {WAFFLE_PLATFORM_WAYLAND,   <span class="Constant">&quot;wayland&quot;</span>       },
    {WAFFLE_PLATFORM_X11_EGL,   <span class="Constant">&quot;x11_egl&quot;</span>       },
    {<span class="Constant">0</span>,                         <span class="Constant">0</span>               },
};

<span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> enum_map context_api_map[] = {
    {WAFFLE_CONTEXT_OPENGL,         <span class="Constant">&quot;gl&quot;</span>        },
    {WAFFLE_CONTEXT_OPENGL_ES1,     <span class="Constant">&quot;gles1&quot;</span>     },
    {WAFFLE_CONTEXT_OPENGL_ES2,     <span class="Constant">&quot;gles2&quot;</span>     },
    {<span class="Constant">0</span>,                             <span class="Constant">0</span>           },
};

<span class="Comment">/// @brief Translate string to `enum waffle_enum`.</span>
<span class="Comment">///</span>
<span class="Comment">/// @param self is a list of map items. The last item must be zero-filled.</span>
<span class="Comment">/// @param result is altered only if @a s if found.</span>
<span class="Comment">/// @return true if @a s was found in @a map.</span>
<span class="Type">static</span> <span class="Type">bool</span>
enum_map_translate_str(
        <span class="Type">const</span> <span class="Type">struct</span> enum_map *self,
        <span class="Type">const</span> <span class="Type">char</span> *s,
        <span class="Type">int</span> *result)
{
    <span class="Type">const</span> <span class="Type">struct</span> enum_map *i;

    <span class="Statement">for</span> (i = self; i-&gt;i != <span class="Constant">0</span>; ++i) {
        <span class="Statement">if</span> (!strncmp(s, i-&gt;s, strlen(i-&gt;s) + <span class="Constant">1</span>)) {
            *result = i-&gt;i;
            <span class="Statement">return</span> <span class="Constant">true</span>;
        }
    }

    <span class="Statement">return</span> <span class="Constant">false</span>;
}

<span class="Comment">/// @return true on success.</span>
<span class="Type">static</span> <span class="Type">bool</span>
parse_args(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[], <span class="Type">struct</span> options *opts)
{
    <span class="Type">const</span> <span class="Type">char</span> *arg;
    <span class="Type">bool</span> ok;

    <span class="Statement">if</span> (argc != <span class="Constant">3</span>)
        error_usage();

    <span class="Comment">// Set platform.</span>
    arg = argv[<span class="Constant">1</span>];
    ok = enum_map_translate_str(platform_map, arg, &amp;opts-&gt;platform);
    <span class="Statement">if</span> (!ok) {
        fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;error: '</span><span class="Special">%s</span><span class="Constant">' is not a valid platform</span><span class="Special">\n</span><span class="Constant">&quot;</span>, arg);
        error_usage();
    }

    <span class="Comment">// Set context_api.</span>
    arg = argv[<span class="Constant">2</span>];
    ok = enum_map_translate_str(context_api_map, arg, &amp;opts-&gt;context_api);
    <span class="Statement">if</span> (!ok) {
        fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;error: '</span><span class="Special">%s</span><span class="Constant">' is not a valid API for a GL context</span><span class="Special">\n</span><span class="Constant">&quot;</span>, arg);
        error_usage();
    }

    <span class="Comment">// Set dl.</span>
    <span class="Statement">switch</span> (opts-&gt;context_api) {
        <span class="Statement">case</span> WAFFLE_CONTEXT_OPENGL:     opts-&gt;dl = WAFFLE_DL_OPENGL;      <span class="Statement">break</span>;
        <span class="Statement">case</span> WAFFLE_CONTEXT_OPENGL_ES1: opts-&gt;dl = WAFFLE_DL_OPENGL_ES1;  <span class="Statement">break</span>;
        <span class="Statement">case</span> WAFFLE_CONTEXT_OPENGL_ES2: opts-&gt;dl = WAFFLE_DL_OPENGL_ES2;  <span class="Statement">break</span>;
        <span class="Statement">default</span>:
            abort();
            <span class="Statement">break</span>;
    }

    <span class="Comment">// Set display_name.</span>
    <span class="Statement">switch</span> (opts-&gt;platform) {
        <span class="Statement">case</span> WAFFLE_PLATFORM_GLX:
        <span class="Statement">case</span> WAFFLE_PLATFORM_X11_EGL:
            opts-&gt;display_name = getenv(<span class="Constant">&quot;DISPLAY&quot;</span>);
            <span class="Statement">break</span>;
        <span class="Statement">case</span> WAFFLE_PLATFORM_WAYLAND:
            opts-&gt;display_name = getenv(<span class="Constant">&quot;WAYLAND_DISPLAY&quot;</span>);
            <span class="Statement">break</span>;
        <span class="Statement">default</span>:
            opts-&gt;display_name = <span class="Constant">NULL</span>;
            <span class="Statement">break</span>;
    }

    <span class="Statement">return</span> <span class="Constant">true</span>;
}

<span class="Comment">/// @}</span>

<span class="Type">static</span> <span class="Type">bool</span>
draw(<span class="Type">struct</span> waffle_window *window)
{
    <span class="Type">int</span> i, j;
    <span class="Type">bool</span> ok;
    <span class="Type">unsigned</span> <span class="Type">char</span> *colors;

    <span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> timespec sleep_time = {
         <span class="Comment">// 0.5 sec</span>
        .tv_sec = <span class="Constant">0</span>,
        .tv_nsec = <span class="Constant">500000000</span>,
    };

    <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">3</span>; ++i) {
        <span class="Statement">switch</span> (i) {
            <span class="Statement">case</span> <span class="Constant">0</span>: glClearColor(<span class="Constant">1</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">1</span>); <span class="Statement">break</span>;
            <span class="Statement">case</span> <span class="Constant">1</span>: glClearColor(<span class="Constant">0</span>, <span class="Constant">1</span>, <span class="Constant">0</span>, <span class="Constant">1</span>); <span class="Statement">break</span>;
            <span class="Statement">case</span> <span class="Constant">2</span>: glClearColor(<span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">1</span>, <span class="Constant">1</span>); <span class="Statement">break</span>;
            <span class="Statement">case</span> <span class="Constant">3</span>: abort(); <span class="Statement">break</span>;
        }

        glClear(GL_COLOR_BUFFER_BIT);

        colors = calloc(WINDOW_WIDTH * WINDOW_HEIGHT * <span class="Constant">4</span>, <span class="Statement">sizeof</span>(*colors));
        glReadPixels(<span class="Constant">0</span>, <span class="Constant">0</span>,
                     WINDOW_WIDTH, WINDOW_HEIGHT,
                     GL_RGBA, GL_UNSIGNED_BYTE,
                     colors);
        <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; WINDOW_WIDTH * WINDOW_HEIGHT * <span class="Constant">4</span>; j += <span class="Constant">4</span>) {
           <span class="Statement">if</span> ((colors[j]   != (i == <span class="Constant">0</span> ? <span class="Constant">0xff</span> : <span class="Constant">0</span>)) ||
               (colors[j+<span class="Constant">1</span>] != (i == <span class="Constant">1</span> ? <span class="Constant">0xff</span> : <span class="Constant">0</span>)) ||
               (colors[j+<span class="Constant">2</span>] != (i == <span class="Constant">2</span> ? <span class="Constant">0xff</span> : <span class="Constant">0</span>)) ||
               (colors[j+<span class="Constant">3</span>] != <span class="Constant">0xff</span>)) {
              free(colors);
              gl_basic_error(<span class="Constant">&quot;glReadPixels returned unexpected result&quot;</span>);
           }
        }
        free(colors);

        ok = waffle_window_swap_buffers(window);
        <span class="Statement">if</span> (!ok)
            <span class="Statement">return</span> <span class="Constant">false</span>;
        nanosleep(&amp;sleep_time, <span class="Constant">NULL</span>);
    }

    <span class="Statement">return</span> <span class="Constant">true</span>;
}

<span class="PreProc">#ifdef __APPLE__</span>

<span class="Type">static</span> NSAutoreleasePool *pool;

<span class="Type">static</span> <span class="Type">void</span>
cocoa_init(<span class="Type">void</span>)
{
    <span class="Comment">// From the NSApplication Class Reference:</span>
    <span class="Comment">//     [...] if you do need to use Cocoa classes within the main()</span>
    <span class="Comment">//     function itself (other than to load nib files or to instantiate</span>
    <span class="Comment">//     NSApplication), you should create an autorelease pool before using</span>
    <span class="Comment">//     the classes and then release the pool when you’re done.</span>
    pool = [[NSAutoreleasePool alloc] init];

    <span class="Comment">// From the NSApplication Class Reference:</span>
    <span class="Comment">//     The sharedApplication class method initializes the display</span>
    <span class="Comment">//     environment and connects your program to the window server and the</span>
    <span class="Comment">//     display server.</span>
    <span class="Comment">//</span>
    <span class="Comment">// It also creates the singleton NSApp if it does not yet exist.</span>
    [NSApplication sharedApplication];
}

<span class="Type">static</span> <span class="Type">void</span>
cocoa_finish(<span class="Type">void</span>)
{
    [pool drain];
}

<span class="PreProc">#endif</span> <span class="Comment">// __APPLE__</span>

<span class="Type">int</span>
main(<span class="Type">int</span> argc, <span class="Type">char</span> **argv)
{
    <span class="Type">bool</span> ok;
    <span class="Type">int</span> i;

    <span class="Type">struct</span> options opts;

    <span class="Type">int32_t</span> init_attrib_list[<span class="Constant">3</span>];
    <span class="Type">int32_t</span> config_attrib_list[<span class="Constant">11</span>];

    <span class="Type">struct</span> waffle_display *dpy;
    <span class="Type">struct</span> waffle_config *config;
    <span class="Type">struct</span> waffle_context *ctx;
    <span class="Type">struct</span> waffle_window *window;

<span class="PreProc">    #ifdef __APPLE__</span>
        cocoa_init();
<span class="PreProc">    #endif</span>

    ok = parse_args(argc, argv, &amp;opts);
    <span class="Statement">if</span> (!ok)
        exit(<span class="Constant">EXIT_FAILURE</span>);

    i = <span class="Constant">0</span>;
    init_attrib_list[i++] = WAFFLE_PLATFORM;
    init_attrib_list[i++] = opts.platform;
    init_attrib_list[i++] = WAFFLE_NONE;

    ok = waffle_init(init_attrib_list);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    glClear = waffle_dl_sym(opts.dl, <span class="Constant">&quot;glClear&quot;</span>);
    <span class="Statement">if</span> (!glClear)
        error_get_gl_symbol(<span class="Constant">&quot;glClear&quot;</span>);

    glClearColor = waffle_dl_sym(opts.dl, <span class="Constant">&quot;glClearColor&quot;</span>);
    <span class="Statement">if</span> (!glClearColor)
        error_get_gl_symbol(<span class="Constant">&quot;glClearColor&quot;</span>);

    glReadPixels = waffle_dl_sym(opts.dl, <span class="Constant">&quot;glReadPixels&quot;</span>);
    <span class="Statement">if</span> (!glReadPixels)
        error_get_gl_symbol(<span class="Constant">&quot;glReadPixels&quot;</span>);

    dpy = waffle_display_connect(opts.display_name);
    <span class="Statement">if</span> (!dpy)
        error_waffle();

    <span class="Statement">if</span> (!waffle_display_supports_context_api(dpy, opts.context_api)) {
        gl_basic_error(<span class="Constant">&quot;Display does not support </span><span class="Special">%s</span><span class="Constant">&quot;</span>,
                       waffle_enum_to_string(opts.context_api));
    }

    i = <span class="Constant">0</span>;
    config_attrib_list[i++] = WAFFLE_CONTEXT_API;
    config_attrib_list[i++] = opts.context_api;
    config_attrib_list[i++] = WAFFLE_RED_SIZE;
    config_attrib_list[i++] = <span class="Constant">8</span>;
    config_attrib_list[i++] = WAFFLE_GREEN_SIZE;
    config_attrib_list[i++] = <span class="Constant">8</span>;
    config_attrib_list[i++] = WAFFLE_BLUE_SIZE;
    config_attrib_list[i++] = <span class="Constant">8</span>;
    config_attrib_list[i++] = WAFFLE_DOUBLE_BUFFERED;
    config_attrib_list[i++] = <span class="Constant">true</span>;
    config_attrib_list[i++] = <span class="Constant">0</span>;

    config = waffle_config_choose(dpy, config_attrib_list);
    <span class="Statement">if</span> (!config)
        error_waffle();

    ctx = waffle_context_create(config, <span class="Constant">NULL</span>);
    <span class="Statement">if</span> (!ctx)
        error_waffle();

    window = waffle_window_create(config, WINDOW_WIDTH, WINDOW_HEIGHT);
    <span class="Statement">if</span> (!window)
        error_waffle();

    ok = waffle_window_show(window);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    ok = waffle_make_current(dpy, window, ctx);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    ok = draw(window);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    ok = waffle_window_destroy(window);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    ok = waffle_context_destroy(ctx);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    ok = waffle_config_destroy(config);
    <span class="Statement">if</span> (!ok)
        error_waffle();

    ok = waffle_display_disconnect(dpy);
    <span class="Statement">if</span> (!ok)
        error_waffle();

<span class="PreProc">    #ifdef __APPLE__</span>
        cocoa_finish();
<span class="PreProc">    #endif</span>

    printf(<span class="Constant">&quot;gl_basic: run was successful</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">return</span> <span class="Constant">EXIT_SUCCESS</span>;
}
</pre>
</body>
</html>
